# 计算机组成原理

## 一.计算机系统论述

### 1.1.计算机发展历程

### 1.2.计算机系统层次结构

1. 早期的冯诺依曼机以**运算器**为中心,且是**单片机**,最根本的特征是采用**存储程序**(按地址访问并顺序执行指令),原理基本工作方式是**控制流驱动方式**.
2. 地址译码器是主存的构成部分,不属于 CPU.地址寄存器虽然一般属于主存,但现代计算机中绝大多数 CPU 内集成了地址寄存器
3. **地址寄存器(MAR)** 存放访存地址,因此位数与**地址码长度**相同.**数据寄存器(MDR)** 用于暂时存储要从存储器中读写的信息,因此位数与**存储字长**相同.
4. 运算器的核心部件是算术逻辑运算单元(ALU),地址寄存器位于 CPU 内,但并未集成到运算器与控制器中.地址寄存器用来保存当前 CPU 所访问的内存单元的地址.由于内存和 CPU 之间存在着操作速度的差别,所以必须使用地址寄存器来保持地址信息,直到内存的读/写操作完成为止.
5. 寄存器在 CPU 内部,速度最快.Cache 采用高速的 SRAM 制作,而内存常用 DRAM 制作,其速度较 Cache 慢.即 CPU 存取速度为:寄存器>Cache>内存.
6. 机器语言是计算机唯一可以直接执行的语言,汇编语言用助记符编写,以便记忆.正则语言是编译原理中符合正则文法的语言.
7. 解释程序的特点是翻译一句执行一句,边翻译边执行;由高级语言转化为汇编语言的过程称为编译,把编译语言翻译成机器语言的过程称为汇编.
8. 数据库系统不属于系统软件.数据库系统是指在计算机系统中引入数据库后的系统,一般由数据库,数据库管理系统,应用程序,数据库管理员构成,其中数据库管理系统是系统程序.
9. 相连存储器既可以按地址寻址又可以按内容(通常是某些字段)寻址,为与传统存储器区别,又称按内容寻址的存储器.
10. 将源程序装换为可执行目标文件的过程分为**预处理,编译,汇编,链接**四个阶段.

### 1.3.计算机的性能指标

1. CPU 主频指 CPU 使用的时钟脉冲频率,CPI 是执行一条指令平均使用的 CPU 时钟数.
2. 机器字长,指令字长和存储字长,三者在数值上可以相等也可以不相等,视不同的机器而定. **一个存储单元中的二进制代码的位数称为存储字长.** 存储字长等于 MDR 的位数,而数据字长是数据总线一次能并行传送信息的位数,它可以不等于 MDR 的位数
3. **计算机的位数,即机器字长,也就是计算机一次能处理的二进制的长度.操作系统的位数是操作系统可寻址的位数**,它与机器字长不同.一般情况下可通过寄存器的位数来判断机器字长.
4. **MFLOPS 是指每秒执行多少百万次浮点运算**,该参数用来描述计算机的浮点运算性能.用于科学计算的计算机(标量机)主要评估浮点运算的性能
5. 汇编程序员可以通过 JMP 指令来设置 PC 的值.状态寄存器,通用寄存器只有为汇编程序员可见,才能实现编程,而 IR,MAR,MDR 是 CPU 内部工作寄存器,对程序员均不可见.
6. **时钟周期即 CPU 频率的倒数**,是最基本的时间单位,CPU 周期又称为机器周期,它由多个时钟周期组成.
7. **吞吐率指系统在单位时间内处请求的数量**,是**一般用户**评价计算机系统性能的综合参数.
8. 提高 CPU 主频,扩大主存容量对性能的提升是有限度的.采用**并行技术**是实现高性能计算机的重要途径,现今超级计算机均采用多处理器来增强并行处理能力.
9. **兼容指计算机软件或硬件的通用性.** 兼容通常在同一系列的不同型号计算机间.
10. **CPI 是平均每条指令的时钟周期数,IPC 是 CPI 的倒数,即每个时钟周期执行的指令数.**
    某计算机的主频为 1.2GHz,其指令分为 4 类,他们在基准程序中所占的比例及 CPI 如下表所示,该机的 MIPS 是 400
    基准程序的 CPI = 2$\times$ 0.5 + 3 $\times$ 0.2 + 4 $\times$ 0.1 + 5 $\times$ 0.2 = 3.
    该计算机的主频为 1.2GHz,即 1200MHz.
    因此,该机器的 MIPS = 1200 $\div$ 3 = 400.
    | 指令类型 | 所占比例 | CPI |
    | :------: | :------: | :-: |
    | A | 50% | 2 |
    | B | 20% | 3 |
    | C | 10% | 4 |
    | D | 20% | 5 |
11. **机器字长是指 CPU 内部用于整数运算的数据通路的宽度.** CPU 内部数据通路是指 CPU 内部的数据流经的路径及路径上的配件,主要是 CPU 内部进行数据运算,存储和传送的部件,这些部件的宽度要一致才能互相匹配.因此,**机器字长等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度.**
12. PFLOPS=每秒一千万亿($10^{15}$)次浮点运算.

## 二.数据的表示和运算

### 2.1.数制与编码

1. 同一个数的补码和移码,其数值部分相同,而符号部分相反.移码用于表示浮点数阶码的机器码,只表示整数.
2. 0 在补码或移码中的表示形式是唯一的. $[0]_补$ = 00000000,$[0]_移 = 2^4$ + 0 = 10000000, $[0]_补$ $\neq$ $[0]_移$.
3. 使用补码表示时,若符号位相同,则数值位越大码值越大.
4. 设 x 为整数,$[x]_补  =1,x_1 x_2 x_3 x_4 x_5$ ,若要 x < -16, $x_1  ~ x_5$ 应满足的条件是 $x_1$ 必须为 0, $x_2  ...  x_5$ 随意, 对补码进行按位取反末尾加一得到原码,-16 的原码为 1,10000,则小于的-16 的原码中$x_1$ 为 1,$x_2  ~ x_5$ 至少有一个为 1.此时按位取反,末尾加一,有 $x_1$ 必定为 0,而 $x_2  ... x_5$ 任意.
5. 当 x 为 0 或为正数时,满足$[-|x|]_补 = [-x]_补$ .
6. -0 只能是原码或者反码,$[-0]_原 = 10000000,[-0]_反 = 11111111$.
7. -1 的补码是 111111111,-128 的补码是 000000000.
8. 负数的反码为原码除符号位外全位取反,正数的反码与原码相同.
9. 计算机内部的定点数大多用补码表示,补码的符号位可以和数值部分一起参加运算,减法可以用加法实现.但补码与真值的对应关系远不如原码与其真值的对应关系简单直接.
10. 原码表示直观,与真值形式相对应,是其他表示形式的基础,但它对加减法运算不方便.补码及反码最大的优点在于对数的加减法运算方便.而移码仅用于阶码的表示.
11. 在计算机中,通常用**无符号数**来表示主存地址.
12. 冯诺依曼结构计算机中的数据采用二进制编码表示,其主要原因是:

    - 二进制的运算规则简单
    - 制造两个稳态的物理器件比较简单
    - 便于用逻辑门电路实现算术运算

13. 真值为负数的时候,求其补码的另一种方法是: 自低位到高位,尾部的第一个 1 和其右部的 0 保持不变,左部的各位取反,符号位保持不变.
14. $[x]_补 求[-x]_补$ 的方法是: 连同符号位一起将各位取反,末尾再加 1.
15. 对于真值,小数不够字长后补 0,整数不够字长符号位后数值位前补 0.
16. 负数的补码等于其反码 + 1,负数的反码等于其补码 - 1.
17. 算术右移 >> :低位溢出,符号位不变,并用符号位补溢出的高位.右移一位相当于除 2.(有损失精度的风险)
18. 算术左移 << :未发生溢出时**符号位不变**,低位补 0.相当于乘 2.(有溢出的风险)
19. 浮点数: 小数点的位置由**阶码**规定,因此是浮动的,用来表示实数,通常把浮点数 N 分成阶码和尾数两部分来表示: $N = 尾数 \cdot 基数 ^{阶码}. 例如: (11100.101)_2 = 0.11100101 \cdot 2^ {101}$.

    另一种浮点数表示方式为 IEEE 754 表示方式

    | $m_s$ |          E          |     m      |
    | :---: | :-----------------: | :--------: |
    | 尾符  | 阶码部分,用移码表示 | 尾数数值位 |

    |    类型    | 尾符(位) | 阶码(位) | 尾数数值(位) | 总位数(位) | 偏移值(十六进制) | 偏移值(十进制) |
    | :--------: | :------: | :------: | :----------: | :--------: | :--------------: | :------------: |
    |  短浮点数  |    1     |    8     |      23      |     32     |       7FH        |      127       |
    |  长浮点数  |    1     |    11    |      52      |     64     |       3FFH       |      1023      |
    | 临时浮点数 |    1     |    15    |      64      |     80     |      3FFFH       |     10383      |

    短浮点数又叫单精度浮点数,长浮点数又叫双精度浮点数,他们都采用隐含尾数最高数位的方法,这样就增加了一位尾数,这样就增加了一位尾数.临时浮点数又称为扩展精度浮点数,无隐含位.

    判断浮点数溢出主要看阶码值是否超过了数据的表示范围.阶码值大于最大阶码值时,称为上溢,不能继续运算,小于最小阶码值时,称为下溢,当做 0 处理.

20. 设$[X]_补 = X_0 .X_{-1 }X_{-2} ...X_{-m} .则[X]_补 = 2\cdot X_0 + X.即 X = -X_0 + \sum_{i = -m}^{-1} X_i2^i$.
21. 反码同样适用于加减法运算,因其模数比补码小 1,故在加减法运算时,若产生模的溢出,需在最低位补 1(称之为循环进位法).
22. BCD 码.常用的 BCD 码有 8421 码,2421 码,余 3 码和格雷码

    - 8421 码用 0000 - 1001 表示 0-9,1010 - 1111 作为非法码(冗余码)
    - 2421 码最高位权值为 2,依次为 421,0 - 4 的最高位为 0,5 - 9 的最高位为 1(权值为 2),其余与 8421 码相同
    - 余 3 码是将 8421 码的每个编码加 3
    - 格雷码可以使用公式直接求出.第 i(i>=0)个格雷码即为: $g_i = i \bigoplus \frac{i}{2}$

### 2.2.运算方法和运算电路

1. 补码加减法

   - 按二进制运算规则运算,逢二进一
   - 若做加法,两数的补码直接相加,若做减法,则将被减数与减数的机器负数相加
   - 符号位与数值位一起参与运算,加减运算结果的符号位也在运算中直接得出
   - 最终运算结果的高位舍弃,保留 n+1 位(机器字长),运算结果亦为补码

   设机器字长为 8 位(含一位符号位),A = 15, B = 24,求$[A+B]_补和[A-B]_补$
   A = +15 = +0001111, B = +24 = +0011000
   得$[A]_补 = 00001111, [B]_补 = 00011000, [-B]_补=11101000$
   所以$[A+B]_补$ = 00001111 + 00011000 = 00100111,符号位为 0,对应真值为+39
   $[A-B]_补$ = 00001111 + 11101000 = 11110111,符号位为 1,对应真值为-9

2. 定点原码一位乘
   设$[X]_原 = x_s.x_1x_2\cdots x_n,[Y]_原 = y_s.y_1y_2\cdots y_n$,运算规则如下

   1. 被乘数和乘数均取绝对值参加运算,看做无符号数,符号位为$x_s\bigoplus y_s$
   2. 部分积是乘法过程的中间结果.乘数的每一位$y_i$乘以被乘数得 X \* $y_i$后,将该结果与前面所得结果累加,就是部分积,初值为 0
   3. 从乘数的最低位$y_n$开始判断:
      - 若$y_n$ = 1,则部分积加上被乘数|X|,然后右移一位
      - 若$y_n$ = 0,则部分积加上 0,然后右移一位
   4. 重复 3,判断 n 次

   由于参与运算的是两个数的绝对值,运算过程中的右移操作均为 **逻辑右移**

   设 x = -0.1101,y = 0.1011,采用原码一位乘法求 $x\cdot y$

   |x| = 00.1101,|y| = 00.1011

   |        | 高位部分积 | 低位部分积/乘数 |        |
   | :----: | :--------: | :-------------: | :----: |
   |        |  00.0000   |     101*1*      | 丢失位 |
   | +\|x\| |  00.1101   |                 |        |
   |        |  00.1101   |                 |        |
   |  右移  |  00.0110   |     110*1*      |   1    |
   | +\|x\| |  00.1101   |                 |        |
   |        |  01.0011   |                 |        |
   |  右移  |  00.1001   |     111*0*      |   11   |
   |   +0   |  00.0000   |                 |        |
   |        |  00.1001   |                 |        |
   |  右移  |  00.0100   |     111*1*      |  011   |
   | +\|x\| |  00.1101   |                 |        |
   |        |  01.0001   |                 |        |
   |  右移  |  00.1000   |     111*1*      |  1011  |

   符号位$P_s = x_s\bigoplus y_s = 1,得 x \cdot y$ = -0.10001111

3. 定点补码一位乘(校正法)

   1. 参加运算的两个操作数都是补码形式,运算结果的符号也是真正的符号
   2. 初始化 A 寄存器(高位部分积)为 0,C(低位寄存器)为乘数的数值位的补码值,**不带符号位**
   3. 判断 C 的最末位
      - 若为 0,下次操作加 0
      - 若为 1,下次操作加$[X]_补$
   4. 然后 A 和 C 寄存器一起右移一位
   5. 重复 3,4 n 次
   6. **如果 Y 的值小于 0,在运算结束时还需要$+[-X]_补$进行校正**

4. 定点原码恢复余数除法

   参加运算的两个数以原码表示,取两数的绝对值相除,商的符号由两数符号的异或值给出

   1. 初始化 A 寄存器的值为**被除数原码的数值位**,C 寄存器初始化为 0
   2. 第一次加$[-Y]_补$运算,如果结果符号不一致则发生溢出
   3. 判断结果符号
      - 余数为正:商上 1
      - 余数为负:商上 0,$+|Y|_原$恢复余数
   4. 寄存器 A 和 C 一起左移 1 位,寄存器 C 末尾补 0
   5. 当寄存器 C 中的商全部求出,并且移位次数和除数数值位一致,运算结束
   6. 商的符号由两数符号的异或值给出,余数的符号与被除数的符号一致
   7. 因为每次求商都左移一位,所以最后所得余数应右移 n 位即乘以 $2 ^{-n }$
   8. **若最后一次商上 0,要得到正确的余数,则在最后一次仍需$+|Y|_原$恢复余数**

5. 提高加法器运算速度最直接的方法是多位并行加法.**进位传递器延迟**对并行加法器的影响最为关键.
6. 加法器中进位信号 $g = X_i Y_i ,进位传递信号 p = X_i \bigoplus Y_i$ .
7. 状态寄存器,数据总线,ALU 属于运算器,地址寄存器属于存储器.
8. 不带进位位的循环左移将最高位进入最低位和标志寄存器.
9. 原码左右移均补 0,且符号位不变,与补码移位方式不同.
10. 小字长变量向大字长变量转换时,如果原数字是无符号整数,则进行**零扩展**,扩展后的高位部分用 0 填充.否则进行**符号扩展**,扩展后的高位部分用原数字符号位填充.
11. 大端方式:从最高有效字节到最低有效字节的顺序存储数据,即最高有效字节放在最前面.(方便人阅读)
    小端方式:从最低有效字节到最高有效字节的顺序存储数据,即最低有效字节放在最前面.(方便计算机阅读)
    设一个数据为 01234567H,大端小端表示如下

    |   地址   | $\cdots$ | 0800H | 0801H | 0802H | 0803H | $\cdots$ |
    | :------: | :------: | :---: | :---: | :---: | :---: | :------: |
    | 大端方式 | $\cdots$ |  01H  |  23H  |  45H  |  67H  | $\cdots$ |
    | 小端方式 | $\cdots$ |  67H  |  45H  |  23H  |  01H  | $\cdots$ |
    | 错误小端 | $\cdots$ |  76H  |  54H  |  32H  |  10H  | $\cdots$ |

12. 模 4 补码具有模 2 补码的全部优点且更容易检查加减运算中的溢出问题.**存储模 4 补码仅需一个符号位**,因为任何一个正确的数值,模 4 补码的两个符号位总是相同的.只在把两个模 4 补码的数送往 ALU 完成加减运算时,才把每个数的符号位的值同时送到 ALU 的双符号位中,即只在 ALU 中才采用双符号位.
13. 若 $[X]_补 = X_0X_1X_2\cdots X_n$,其中$X_0$为符号位,$X_1$为最高数位,若$X_0 \neq X_1$则当补码左移时,将会发生溢出

    溢出判别法有两种情况适用于此种情况:

    - 加一个符号位变为双符号位,然后左移,若两符号位不同则溢出
    - 数值位最高位进位和符号位进位不同则溢出

14. 在原码一位乘法中,最多需要 n 次移位,n + 1 次加法运算.原码乘法移位和加法运算最多均为 n 次.
15. 实现 N 位(不包括符号位)补码一位乘法时,乘积为 2N + 1 位
    补码一位乘法运算过程中一共向右移位 N 次,加上原先的 N 位,一共是 2N 为数值位,因乘积结果需加上符号位,因此一共 2N + 1 位.
16. 原码不恢复余数法只在最终余数为负时,才需要恢复余数,补码不恢复余数除法最终无论余数正负都不需要恢复余数.
17. 在算术移位的情况下,双符号的移位操作只有低符号位需要参加移位操作.
18. 不管是补码减法还是无符号数减法,都是用被减数加上减数的负数的补码实现的,减数 y 的负数的补码$[-y]_补 = \bar{y} + 1$.因此,在加法器的 Y'输入端用一个反向器实现,并用控制端 Sub 控制多路选择器是否将 y 的各位取反后,输入 Y'端,同时将 Sub 作为低位进位送到加法器.当 Sub 为 1 时,做减法,Sub = 1 控制将$\bar{Y}$输入到加法器 Y'端,实现各位取反,同时将 Sub = 1 作为低位进位送到加法器,实现末尾加一.
19. C 语言的数据在内存中为补码形式.
20. 在按字节编址,采用小端方式的 32 位计算机中,按边界对齐方式为以下 C 语言结构类型变量 a 分配存储空间

    ```c
    struct record{
    short x1;
    int x2;
    } a;
    ```

    若 a 的首地址为 2020FE00H,a 的成员变量 x2 的机器数为 12340000H,则其中 34H 所在的存储单元的地址是 2020FE06H

    | 地址 | 2020FE00H | 2020FE01H | 2020FE02 | 2020FE03H |
    | :--: | :-------: | :-------: | :------: | :-------: |
    | 内容 |   未知    |   未知    |          |           |
    | 说明 |  x1(LSB)  |  x1(MSB)  |          |           |
    | 地址 | 2020FE04H | 2020FE05H | 2020FE06 | 2020FE07H |
    | 内容 |    00H    |    00H    |   34H    |    12H    |
    | 说明 |  x2(LSB)  |  x2(MSB)  |          |           |

21. 补码或原码除法运算中,左移操作时,符号位也参与运算.
